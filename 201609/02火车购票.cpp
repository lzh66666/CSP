#include <bits/stdc++.h>

using namespace std;

int n;          //购票指令的数量
int a[21][6];	//模拟车厢
int b[103];     //购票之后的座位号存储
int q = 1;      //购买座位数的坐标
int m[103];     //每个人的购票数量
int c[23];      //该排的座位剩余数量

int main(){
	for(int i = 1; i <= 20; i++){
		c[i] = 5;	//初始化每排的座位数
		for(int j = 1; j <= 5; j++){
			a[i][j] = (i-1)*5+j;
		}
	}
	
	cin >> n;

    int max = 0;
	for(int k = 1; k <= n; k++){
		cin >> m[k];
		int d = m[k];
		//此处加一个判断不知为何就会扣掉30分，啊啊啊啊啊啊啊！！！！！！！！！！！！！！读题读题再读题
		for(int i = 1; i <= 20; i++){
			if(m[k] <= c[i]){   //购买的票数小于当前排的数量才能继续购买
				for(int j = 1; j <= 5; j++){
					if(a[i][j] && d > 0){    //有座位并且没到达自己购买的上限
						b[q++] = a[i][j];       //记录购买的座位号
						c[i]--;                 //当前排的座位数减一
						a[i][j]=0;              //座位购买，该座位有人
						d--;                    //购买票数加一
					}
				}
				max = max > c[i] ? max : c[i];
				break;                          //购买完成退出，防止二次判断
			}
			max = max > c[i] ? max : c[i];
		}
		//之前忘记判断 第21个人以后的特殊情况，只有90分，啊啊啊啊啊啊啊啊啊！！！！！！！！！！！！！！
		if(k > 20 && m[k] > max){
			for(int i = 1; i <= 20; i++){
				if(c[i]){
					for(int j = 1; j <= 5; j++){
						if(a[i][j] && d > 0){
							b[q++] = a[i][j];       //记录购买的座位号
							c[i]--;                 //当前排的座位数减一
							a[i][j]=0;              //座位购买，该座位有人
							d--;
						}
					}
					if(d == 0){
						max = max > c[i] ? max : c[i];
						break;
					}
				}
				max = max > c[i] ? max : c[i];
			}
		}
	}
	int d = 1;
	int k = 1;
	for(int i = 1; i < q; i++){
		cout << b[i] << " ";
		if(d == m[k]){
			if(k != n){
				cout << "\n";
				d = 0;
				k++;
			}else{
				break;
			}
		}
  		d++;
	}
	return 0;
}
//注意：读题读题再读题！
//因为这句话=======否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。====三个小时没了，气煞我也！！！！！！！！
/*=================================================================
输入
4
2 5 4 2

输出
1 2
6 7 8 9 10
11 12 13 14
3 4
=================================================================*/
/*
问题描述
　　请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。
　　假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，
	第20排是96到100号。
　　购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。
	否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。
　　假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。

输入格式
　　输入的第一行包含一个整数n，表示购票指令的数量。
　　第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。

输出格式
　　输出n行，每行对应一条指令的处理结果。
　　对于购票指令p，输出p张车票的编号，按从小到大排序。

样例输入
4
2 5 4 2

样例输出
1 2
6 7 8 9 10
11 12 13 14
3 4

样例说明
　　1) 购2张票，得到座位1、2。
　　2) 购5张票，得到座位6至10。
　　3) 购4张票，得到座位11至14。
　　4) 购2张票，得到座位3、4。

评测用例规模与约定
　　对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。
*/
