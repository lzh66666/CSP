#include <iostream>
#include <string>
#include <math.h>

using namespace std;

struct RGB {
	int r;
	int g;
	int b;
	RGB() {};
	RGB(int _r, int _g, int _b) {
		r = _r, g = _g, b = _b;
	}
}xs[1080][1920];

int to_int(char c) {
	if (c >= '0' && c <= '9')   return c - '0';
	else return c - 'a' + 10;
}

int hex_to_int(string s) {
	int len = s.length();
	int result = 0;
	for (int i = 0; i < len; i++)
		result += to_int(s[i]) * pow(16, len - i - 1);
	return result;
}

int main() {
	ios::sync_with_stdio(false);
	int m, n, p, q;
	cin >> m >> n >> p >> q;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			string str;
			cin >> str;
			int r, g, b;
			if (str.length() == 7) {
				r = hex_to_int(str.substr(1, 2));
				g = hex_to_int(str.substr(3, 2));
				b = hex_to_int(str.substr(5, 2));
			}
			else if (str.length() == 4) {
				r = hex_to_int(string(2, str[1]));
				g = hex_to_int(string(2, str[2]));
				b = hex_to_int(string(2, str[3]));
			}
			else if (str.length() == 2) {
				r = g = b = hex_to_int(string(2, str[1]));
			}
			xs[i][j] = RGB(r, g, b);
		}
	}

	for (int i = 0; i < n; i += q) {
		int pr, pg, pb;
		int r = 0, g = 0, b = 0;
		bool same = false;
		for (int j = 0; j < m; j += p) {
			pr = r, pg = g, pb = b;
			r = g = b = 0;
			for (int ii = i; ii < i + q; ii++) {
				for (int jj = j; jj < j + p; jj++) {
					r += xs[ii][jj].r;
					g += xs[ii][jj].g;
					b += xs[ii][jj].b;
				}
			}
			r /= p * q, g /= p * q, b /= p * q;
			if (pr == r && pg == g && pb == b)  same = true;
			else    same = false;
			if (!same) {
				string str = "\\x1B\\x5B";

				if (r == 0 && g == 0 && b == 0) {
					str += "\\x30\\x6D\\x20";
				}
				else {
					str += "\\x34\\x38\\x3B\\x32\\x3B";
					string sr, sg, sb;
					sr = to_string(r);
					sg = to_string(g);
					sb = to_string(b);
					for (int k = 0; k < sr.length(); k++)   str += "\\x3" + string(1, sr[k]);
					str += "\\x3B";
					for (int k = 0; k < sg.length(); k++)   str += "\\x3" + string(1, sg[k]);
					str += "\\x3B";
					for (int k = 0; k < sb.length(); k++)   str += "\\x3" + string(1, sb[k]);
					str += "\\x6D\\x20";
				}
				cout << str;
			}
			else {
				cout << "\\x20";
			}
		}
		if (!(r == 0 && g == 0 && b == 0)) {
			cout << "\\x1B\\x5B\\x30\\x6D";
		}
		cout << "\\x0A";
	}
	return 0;
}

/*****************
2 2
1 2
#111111
#0
#000000
#111

1 1
1 1
#010203

3 2
1 2
#0
#0
#010101
#010102
#0
#0

******************/

/*
#010203

样例一输出
\x1B\x5B\x34\x38\x3B\x32\x3B\x31\x3B\x32\x3B\x33\x6D\x20\x1B\x5B\x30\x6D\x0A

样例二输入
2 2
1 2
#111111
#0
#000000
#111

样例二输出
\x1B\x5B\x34\x38\x3B\x32\x3B\x38\x3B\x38\x3B\x38\x6D\x20\x1B\x5B\x30\x6D\x0A

*/

/*
[题目背景]
君君是个喜欢旅行的女孩子，世界那么大，她哪里都想去看看。这个暑假，她踏遍了大江南北，感慨于祖国幅员的辽阔。开学了，君君打算整理一下最近拍的照
片，却发现自己电脑上Linux的图形界面似乎罢工了。面对着终端里不断闪动的光标，她灵机一动.

[题目描述]
本题中，你需要将图片转换为终端中可以显示的字符画。
你将得到一张24位图片，这意味着其中的像素表示为RGB三原色的形式，而每种颜色的取值范围为0到255 (一个字节)，因此每个像素占用的空间为24比特。你需
要这张图片分割为指定数量的块。对于每一- 块，你需要计算所有像素的三个颜色分量的平均值，并输出对应颜色的字符形成字符画。
为了在终端中输出彩色的字符，你需要使用特殊的转义序列。在目前通行的终端规范中，与颜色相关的转义序列包括:
●ESC [ 38; 2; R; G; B m更改终端的前景色(字符的颜色)为(R,G, B)
●ESC[48;2;R;G;Bm更改终端的背景色(未被字符遮盖处的颜色)为(R,G, B)
●ESC [ 0 m重置终端的颜色状态为默认值(前景色为白色(255, 255,255),， 背景.色为黑色(0,0,0))你只需要在输出中加入这些转义序列，就能够控制终端中
显示的字符颜色。在书写转义序列时，有以下注意事项:
●所有空格都是为了方便辨认而添加的，不需要出现在实际的转义序列输出中
●ESC不是字面上的三个字符，而是ASCII序号为27 (八进制表示为033)的一个字符，代表转义序列的开始。在C/C++/Java/Python中，你都可以使用
\033或\x1b来在字符串中使用这个字符。
●每个颜色分量的值需要在0到255的范围内
●对终端状态的更改在当前转义序列结束(即最后的m字符)后立刻生效，直到下一个序列再次改变状态为止为了更方便理解，
我们给出一一个例子(为了显示效果而分行，实际输出时为一行):
\033[38; 2; 255;0;0mHe11o\033[ 0m \033[38;2;0;0; 255m
\033[48; 2;255;255; 255mWor1d\033[ 0m\n
当这个字符串被输出到终端中，你将会看到类似下面的效果:
特别需要注意的是，在程序完成输出后，应该主动恢复终端的颜色状态，否则可能
让之后运行的程序表现异常。
Hel1o world

[输入格式]
从标准输入读入数据。
输入的第一行为两个整数m,n,分别表示图片的宽和高。第二行为两个整数p,q,
分别表示每一-小块的宽和高。保证p整除m,并且q整除n,也就是说图片总是能被
分割成整数块。.
接下来共有mxn行，每一行是图片中的一.个像素，按照从左到右、从上到下的顺
序列出。每个像素的颜色以HTML颜色代码的形式表示，格式为#abcdef，表示该像
素的R、G、B三个分量分别是(0xab，excd, exef) (注意为16进制)。此外，为
了使得表达简洁，#aabbcc 可以被缩写为#abc, #aaaaa 可以被缩写为#a，你需要
处理这些情况。

[输出格式]
输出到标准输出。
输出包含两部分，每一个输出中应该有恰好(mn)/(pq) 个空格( )以及n/q个
换行符('\n'),和若干个转义序列。空格用于绘制色块(呈现出的即为其背景色)，转
义序列用于改变颜色。每一一个色块都由pXq个像素组成，其三个颜色分量值分别是对
应区域中所有像素该分量值的平均值(除法向零取整即可)。
由于正确的答案显然不止一一种，为了方便判定，我们有以下的约定:
●初始时终端的前景色和背景色都为默认值(前景白色，背景黑色)
●减少控制序列的冗余，这包含以下的情况:
-如果下一个字符的颜色刚好与默认值完全相同，你应当直接使用重置转义序列，而非手动更改颜色
-如果某个字符的前景色/背景色与其前一一个字符相同，或者对颜色的更改并不影响最终显示效果，则不应该出现更改这个属性的控制序列
●在输出每一-行字符后，如果终端颜色不是默认值，你应该重置终端的颜色状态
为了便于观察和评测，你需要将输出中的所有字符转换为ASCII编码转义后的格
式再进行输出。即，如果某个字符的16 进制编码是0xAB，则你应该在输出文件中写
入\xAB,注意大小写。所有的字符都需要被转义(包括空格、换行等空白字符);所有
字符的转义序列顺序输出，不需要任何形式的分隔符号:在输出所有的转义序列后，不
需要写入换行符。也就是说，最终的输出文件只有一行，并且其中所有内容都是原本输
出字符的ASCII转义序列。
如果你使用的是Linux系统，你可以在终端中运行如下的命令查看输出文件的真
实显示效果(其中1.out是文件名):
echo -ne $(cat 1. out)

[样例1输入]
11
11
#010203

[样例1输出]
\x1B\x5B\x34\x38\x3B\x32\x3B\x31 \x3B\x32\x3B
\x33\x6D\x20\x1B\x5B\x30\x6D\x0A
注意上面的换行是由于排版限制而添加的，实际输出中无需也不能换行。

[样例1解释]
输入文件图片大小为1x1,要求的色块大小为1 x 1,因此原样输出即可。在输出
后需要重置背景色。

[样例2输入]
22
12
#111111
#0
#000000
#111

[样例2输出]
\x1B\x5B\x34 \x38\x3B\x32\x3B\x38 \x3B\x38\x3B
\x38\x6D\x20\x20\x1B\x5B\x30\x6D\x0A
此处的换行同样是由于排版限制添加的。

[样例2解释]
输入文件图片大小为2x2，要求的色块大小为1 x2，因此将被切为两个色块。
第一个色块的颜色是左侧两个像素的平均值，三个颜色分量为(8,8,8);第二个色
块同理，计算得到的颜色分量相同。因此最终只需要更改-次终端的背景色，并输出两
个空格用于显示即可。

[子任务]
见图03.jpg
*/
