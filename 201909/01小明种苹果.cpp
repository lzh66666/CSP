#include <stdio.h>

int a[1000][1000];//必须定义成全局变量，否则不得分

int main(){
    int n=0,m=0;
    scanf("%d%d",&n,&m);
    int sum[n];     //记录每棵树的蔬果数（负数）
    int s = 0;      //苹果树现有的树
    
    for(int i = 0 ; i < n ; i++){
    	sum[i] = 0;
    	for(int j = 0 ; j < m+1 ; j++){
    		scanf("%d",&a[i][j]);
    		if(j != 0)
    			sum[i] += a[i][j];
		}
		s += a[i][0]+sum[i];
	}
	
	int max = sum[0];
	int c = 0;      //蔬果数最多的树
	
	for(int i = 1 ; i < n ; i++){
		if(max > sum[i]){
			max = sum[i];
			c = i;
		}
	}
	
	printf("%d %d %d",s,c+1,-max);
    return 0;
}

/*
[题目描述]
小明在他的果园里种了一些苹果树。为了保证苹果的品质，在种植过程中要进行若干轮疏果操作，也就是提前从树.上把不好的苹果去掉。第一轮疏果操作开始前，
小明记录了每棵树上苹果的个数。每轮疏果操作时，小明都记录了从每棵树上去掉的苹果个数。在最后一轮疏果操作结束后，请帮助小明统计相关的信息。

[输入格式]
从标准输入读入数据。
第1行包含两个正整数N和M,分别表示苹果树的棵数和疏果操作的轮数。
第1+i行(1≤i≤N)，每行包含M+ 1个整数a.j....其中a;o 为正整数，表示第一轮疏果操作开始前第i棵树上苹果的个数。an; (1≤j≤M)为零或负整
数，表示第j轮疏果操作时从第i棵树上去掉的苹果个数。如果为零，表示没有去掉苹
果;如果为负，其绝对值为去掉的苹果个数。
每行中相邻两个数之间用一-个空格分隔。

[输出格式]
输出到标准输出。
输出只有一行，包含三个整数T、k和P。其中，
●T为最后一轮疏果操作后所有苹果树上剩下的苹果总数(假设苹果不会因为其他原因减少);
●k为疏果个数(也就是疏果操作去掉的苹果个数)最多的苹果树编号(如有并列，.输出满足条件的最小编号);
●P为该苹果树的疏果个数。
相邻两个数之间用一个空格分隔。输入数据保证是正确的，也就是说，每棵树在全部疏果操作结束后剩下的苹果个数是非负的。

[样例1输入]
33
73-8-6-4
76 -5 -10 -8
80-6-150

[样例1输出]
167 2 23

[样例1解释]
第1棵苹果树的疏果个数为8+6+4=18，第2棵为5+10+8=23，第3棵为6+ 15+0= 21,因此最后一.轮疏果操作后全部苹果树上的苹果个数总和为
(73- 18)+ (76-23)+(80-21)= 167， 疏果个数最多的是第2棵数，其疏果个数为23。

[样例2输入]
22
10 -3 -1
15-40

[样例2输出]
17 1 4

[样例2解释]
两棵树的疏果个数均为4，应该输出编号最小的第1棵树。

[子任务]
见图01.jpg

|a;|≤10°，对所有1≤i≤N,0≤j≤M.

*/
