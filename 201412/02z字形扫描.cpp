#include <bits/stdc++.h>

using namespace std;

int n;
int a[500][500];

int main(){
	
	cin >> n;
	for(int i = 0; i < n; i++){
		for(int j = 0; j < n; j++){
			cin >> a[i][j];
		}
	}
	
	int m = n*n;    		//计算a数组的长度
	
	int i = 0,j = 0;        //计算出的数组a应该的下标，第一个为0,0
	int i1 = 0, j1 = 0;     //i1,j1为每次i和j变化的约束条件
	int i2 = 0, j2 = 0;     //i2和j2是辅助i1和j1的，因为这个困扰了半天，啊啊啊啊啊啊啊啊啊！！！！！！！！！！！！！！！
	
	int dire = 1;       	//方向，1代表右上方移动，0代表左下方移动
	bool judge_l = false;   //左下方移动的判断条件
	bool judge_r = false;   //右上方移动的判断条件
	bool judge = true;      //这个是防止条件假装满足的，刚开始没有考虑，啊啊啊啊啊啊啊啊！
	
	while(m){
		m--;
		cout << a[i][j] << " ";
		/*
			(i == i1 && judge)为到达最上方第一次所满足的条件，刚开始想的是0，没有用i1，一大失误，之后没有加judge判断，二大失误
			judge_l为非第一次满足的条件，也应该进入
		*/
		if(judge_l || (i == i1 && judge) ){
			if(dire == 1){
				if(j == n-1){       //第一次抵达顶部，并且到达最右边
					i++;             //应该向下走
					i1++;           //下次到达的顶部应该向下移动，移动两格，但为了应付i == i1先加1，因为此时judge_l不满足并且还想进入
					i2++;           //为了解决i1的问题，专门设置此变量，最后退出时再赋值给i1
				}else{              //第一次抵达顶部，不在最右边，应该向右走
					j++;            //如果此时到达次右边（n-2），再执行j++，就到达最右边，为了下次到达的的正确，执行下面的i2++
				}
				dire = 0;
			}else{
				if(j == n-1){       //如果到达最右边，因为上面只加1，此时再加1，如果到达次右边（n-2），也需要加1
					i2++;
				}
				i++;                //向左下方移动，行数加一
				j--;                //向左下方移动，列数减一
				if(j == j1){        //到达最左边，退出，执行下一部分
					judge_l = false;
					judge = false;
					i1 = i2;
				}else{
					judge_l = true;
				}
			}
			
		}else{
			if(judge_r || (j == j1 && !judge)){
				if(dire == 0){
					if(i == n-1){
						j++;
						j1++;
						j2++;
					}else{
						i++;
					}
					dire = 1;
				}else{
					if(i == n-1){
						j2++;
					}
					j++;
					i--;
					if(i == i1){
						judge_r = false;
						judge = true;
						j1 = j2;
					}else{
						judge_r = true;
					}
				}
			}
		}
	}
	
	return 0;
}

/*=================================================================
输入
4
1 5 3 9
3 7 5 6
9 4 6 4
7 3 1 3
输出
1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3
=================================================================*/
/*
问题描述
　　在图像编码的算法中，需要将一个给定的方形矩阵进行Z字形扫描(Zigzag Scan)。给定一个n×n的矩阵，Z字形扫描的过程如02.jpg图所示：
	对于下面的4×4的矩阵，
　　1 5 3 9
　　3 7 5 6
　　9 4 6 4
　　7 3 1 3
　　对其进行Z字形扫描后得到长度为16的序列：
　　1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3
　　请实现一个Z字形扫描的程序，给定一个n×n的矩阵，输出对这个矩阵进行Z字形扫描的结果。
输入格式
　　输入的第一行包含一个整数n，表示矩阵的大小。
　　输入的第二行到第n+1行每行包含n个正整数，由空格分隔，表示给定的矩阵。
输出格式
　　输出一行，包含n×n个整数，由空格分隔，表示输入的矩阵经过Z字形扫描后的结果。
样例输入
4
1 5 3 9
3 7 5 6
9 4 6 4
7 3 1 3
样例输出
1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3
评测用例规模与约定
　　1≤n≤500，矩阵元素为不超过1000的正整数。
*/
